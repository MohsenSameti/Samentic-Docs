{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Samentic Docs","text":"<ul> <li> Gradle</li> </ul>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Samentic Docs</li> <li>Gradle<ul> <li>Tips and Tricks<ul> <li>Filter Build Variants</li> <li>Rename Output Files</li> </ul> </li> <li>Webinars<ul> <li>Official<ul> <li>Jvm Builds</li> </ul> </li> </ul> </li> </ul> </li> </ul>"},{"location":"gradle/","title":"Gradle","text":"<ul> <li> Tips and Tricks</li> <li> Webinars and Talks</li> </ul>"},{"location":"gradle/tips-and-tricks/","title":"Gradle Tips and Tricks","text":"<ul> <li> <p>Rename Outputs Files</p> <p>Change the generated apk and bundle files</p> </li> <li> <p>Filter Build Variants</p> <p>Remove unwanted generated build variants of gradle </p> </li> </ul>"},{"location":"gradle/tips-and-tricks/build-variant-filtering/","title":"Filter Build Variants","text":"<p>Gradle allows configuring build variants by changing Build Types, Product Flavors and Dimensions which could create a boatload of variants which we don't want. we can use the following code to filter them out and remove the useless ones:</p> GroovyKotlin <pre><code>android {\n    // ...\n    variantFilter { variant -&gt;\n        // this is a list because if we apply dimensions, each variant we consists\n        // of multiple flavors\n        def names = variant.flavors*.name\n        // not we check the conditions that we want...\n        if ((names.contains(\"direct\") &amp;&amp; variant.buildType.name == \"debug\")) {\n            variant.ignore = true // setting this to true we make the variant go away :)\n        }\n    }\n}\n</code></pre> <pre><code>android {\n    // ...\n}\n// note that this is a sibling of android block\nandroidComponents {\n    beforeVariants { variantBuilder -&gt;\n        // change the condition to whatever you want\n        // name is the fullName of variant, consisting of flavors and build type\n        if(variantBuilder.name == \"something\") {\n            variantBuilder.enable = false // setting this to false we make the variant go away :)\n        }\n    }\n}\n</code></pre>"},{"location":"gradle/tips-and-tricks/build-variant-filtering/#reference","title":"Reference","text":"<p>developer.android: Configure Build Variants</p>"},{"location":"gradle/tips-and-tricks/rename-output-files/","title":"Rename Output Files","text":"<p>This fllowing code snippets allow you to change the generated apk and bundle files so you do not have to build it automatically.</p>"},{"location":"gradle/tips-and-tricks/rename-output-files/#apk","title":"Apk","text":"<p>if we want to change the name of the generated apk files for all build variants we can use android.applicationVariants block:</p> GroovyKotlin <pre><code>android {\n    // ...\n    applicationVariants.all { variant -&gt;\n        variant.outputs.all {\n            outputFileName = \"MyName.apk\" // put apk name here\n        }\n    }\n}\n</code></pre> <pre><code>android {\n    // ...\n    applicationVariants.all {\n        // the case is necessary to be able to access outputFileName\n        outputs.map { it as com.android.build.gradle.internal.api.BaseVariantOutputImpl }\n            .forEach { variant -&gt;\n                variant.outputFileName = \"MyName.apk\"\n            }\n    }\n}\n</code></pre> <p>Another solution for kotlin dsl can be found here!</p>"},{"location":"gradle/tips-and-tricks/rename-output-files/#bundles","title":"Bundles","text":"GroovyKotlin <pre><code>// DO NOT FORGET THIS. put if at the top of gradle file!\nimport com.android.build.gradle.internal.tasks.FinalizeBundleTask\n// ...\nandroid {\n    // ...\n    applicationVariants.all {\n        tasks.named(\"sign${variant.name.capitalize()}Bundle\", FinalizeBundleTask) {\n            val artifactName = \"MyBundle\" // change to whatever you want\n            File file = finalBundleFile.asFile.get()\n            File finalFile = new File(file.parentFile, \"${artifactName}.aab\")\n            finalBundleFile.set(finalFile)\n        }\n    }\n}\n</code></pre> <pre><code>// DO NOT FORGET THIS. put if at the top of gradle file!\nimport com.android.build.gradle.internal.tasks.FinalizeBundleTask\n// ...\nandroid {\n    // ...\n    applicationVariants.all {\n        val variant = this\n        tasks.named(\"sign${variant.name.capitalize()}Bundle\", FinalizeBundleTask::class) {\n            val artifactName = \"MyBundle\" // change to whatever you want\n            val file = finalBundleFile.asFile.get()\n            val finalFile = File(file.parentFile, \"${artifactName}.aab\")\n            finalBundleFile.set(finalFile)\n        }\n    }\n}\n</code></pre>"},{"location":"gradle/webinars/","title":"Gradle Webinars and Talks","text":"<ul> <li> <p>Official Gradle Webinars</p> <p>These are training webinars held by gradle organization in 2023.</p> </li> </ul>"},{"location":"gradle/webinars/official/","title":"Official Gradle Webinars","text":"<ul> <li> <p>Introduction To Gradle Build Tool</p> </li> <li> <p>JVM Builds with Gradle Build Tools</p> </li> <li> <p>Android Apps with Gradle Build Tool</p> </li> <li> <p>Build Cache Deep Dive</p> </li> <li> <p>Gradle Build Tool Configuration Organization</p> </li> <li> <p>Performance Optimization</p> </li> <li> <p>Advanced Dependency Management</p> </li> <li> <p>Plugin Development</p> </li> <li> <p>Maintain Build Cache Across Many Projects</p> </li> </ul>"},{"location":"gradle/webinars/official/jvm-builds/","title":"Jvm Builds","text":""},{"location":"gradle/webinars/official/jvm-builds/#evolution-of-build-tools","title":"Evolution of Build Tools","text":"<p>As with everything, build tools evolve over time. if we consider a car at the beginning, it only has Accelerate, Turn and Brake which are basic things a car needs. But overtime more things are are added to the cars like Seat Belts, Self Parking, etc.</p> <p></p> <p>As you can see in the following image, at the beginning build tools only consisted of basic features which are a way to compile the app, run application tests and package the app.</p> <p></p> <p>and as time passed more features were added to build systems Dependency Management, Static code analysis and Test Grouping.</p> <p></p> <p>They are evolving continuously to Help us create code better and they do a lot of heavy lifting behind the scenes like dependency management.</p>"},{"location":"gradle/webinars/official/jvm-builds/#gradle-jvm-plugins","title":"Gradle JVM Plugins","text":"<p>As you (should) know gradle by itself provide minimal configuration and most thing are added to it by applying plugins. The same goes for java and other jvm languages kotlin, groovy and scala.</p> <p>In this section we check common used plugins in jvm builds for java, kotlin, groovy and scala languages.</p>"},{"location":"gradle/webinars/official/jvm-builds/#java-plugins","title":"Java Plugins","text":"<p>For java there are 3 main plugins when it comes to java: <code>java</code> plugin, <code>java-library</code> plugin and <code>application</code> plugin</p> <ul> <li> <p><code>java</code> plugin</p> <p>This plugin is the base java plugin which provides source code locations for java which are called SourceSets.</p> <ul> <li><code>src/main/java</code></li> <li><code>src/test/java</code></li> </ul> <p>adds tasks like compileJava and test for compiling the source codes and running tests respectively  </p> </li> <li> <p><code>java-library</code> plugin</p> <p>This plugins applies the java plugin automatically which means by applying it we will have everything the java plugin has.</p> <p>Add api dependency configuration which will talk more about it later.</p> </li> <li> <p><code>application</code> plugin</p> <p>This plugins applies the java plugin automatically which means by applying it we will have everything the java plugin has.</p> <p>Adds build configuration to determine main class</p> <p>Adds run and package tasks to run the application (via the main class provided) and package the app respectively</p> </li> </ul>"},{"location":"gradle/webinars/official/jvm-builds/#kotlin-plugin","title":"kotlin plugin","text":"<p>It is <code>org.jetbrains.kotlin.jvm</code> plugin which is maintained by jetbrains.</p> <p>This plugins applies the java plugin automatically which means by applying it we will have everything the java plugin has.</p> <p>Adds sourceSets for kotlin code which can be used along side normal java sourceSets:</p> <ul> <li><code>src/main/kotlin</code></li> <li><code>src/test/kotlin</code></li> </ul> <p>Never put <code>java</code> files inside kotlin sourceSets. they will not be compiled. put them in the appropriate java sourceSet (<code>src/main/java</code> or <code>src/test/java</code>)</p> <p>Adds CompileKotlin task to compile kotlin code.</p> <p><code>java-library</code> and <code>application</code> plugins can be applied along side this plugin to add more functionality.</p>"},{"location":"gradle/webinars/official/jvm-builds/#groovy-plugin","title":"groovy plugin","text":"<p>This plugin extends the <code>java</code> plugin.</p> <p>Adds sourceSets for kotlin code which can be used along side normal java sourceSets:</p> <ul> <li><code>src/main/groovy</code></li> <li><code>src/test/groovy</code></li> </ul> <p>Adds CompileGroovy task to compile groovy code.</p> <p>Can be used along side java.</p> <p><code>java-library</code> and <code>application</code> plugins can be applied along side this plugin to add more functionality.</p>"},{"location":"gradle/webinars/official/jvm-builds/#scala-plugin","title":"scala plugin","text":"<p>This plugin extends the <code>java</code> plugin.</p> <p>Adds sourceSets for kotlin code which can be used along side normal java sourceSets:</p> <ul> <li><code>src/main/scala</code></li> <li><code>src/test/scala</code></li> </ul> <p>Adds CompileScala task to compile scala code.</p> <p>Can be used along side java.</p> <p><code>java-library</code> and <code>application</code> plugins can be applied along side this plugin to add more functionality.</p>"},{"location":"gradle/webinars/official/jvm-builds/#source-organization","title":"Source Organization","text":"<p><code>SourceSets</code> are configurations which are provided by the plugins in order to logically group sources. Basically they tell gradle where our source codes are.</p> <p>By default there are 2 sourceSets: <code>main</code> and <code>test</code>. It is possible to change the default location of source files (check here) but it is recommended to use the default ones.</p>"},{"location":"gradle/webinars/official/jvm-builds/#how-are-sourcesets-useful","title":"How are sourceSets useful?","text":"<p>In order to answer these question we check these two scenarios:</p> <ul> <li>Handle Generated Source Codes</li> <li>Running Expensive Tests</li> </ul>"},{"location":"gradle/webinars/official/jvm-builds/#handling-generated-source-codes","title":"Handling Generated Source Codes","text":"<p>Some tasks in our projects generate code dynamically (like annotation processors). It is recommended not to push these codes in source control and put them under <code>build/generated</code>. </p> Why shouldn't we add generated sources to source control? <ul> <li> <p>Redundency &amp; Size: Generally size of generated sources is large and is easily reproducable. This means the Repository size is increased unnecessarily.</p> </li> <li> <p>Merge conflicts: These files, especially if they change frequently, can lead to an increased number of merge conflicts in version control systems. This can happen when different developers generate slightly different versions of these files on their local machines.</p> </li> <li> <p>Reproducibility: If generated files are included in version control, there's a risk that builds on different machines might rely on slightly different versions of these files, leading to inconsistencies.</p> </li> <li> <p>Maintainabiliy: By not tracking these files in version control, you ensure that your repository only contains the essential source files that developers need to work with. This makes the repository cleaner and more maintainable.</p> </li> </ul> <p>For This Reason we put the generated source under <code>build/generated/sources</code> directoru and add it as a sourceSet to gradle so it automatically looks in those folder for sources.</p> <p>In order to add a location to a sourceSet we do the following:</p> <pre><code>sourceSets {\n    main {\n        java {\n            srcDir(\"&lt;path&gt;\")\n        }\n    }\n}\n</code></pre> <p>This path is static and if the task which generates the code, changes it then we must change it here as well (also we need to remember to execute that task before the compile, so sources are generated) but we can use inferred task dependency  to avoid that: </p> <pre><code>sourceSets {\n    main {\n        java {\n            srcDir(tasks.named(\"someTask\"))\n        }\n    }\n}\n</code></pre> <p>Now by doing this, we automatically use the correct location if it is changed, also someTask task is automatically executed before the compile task so source generation is done.</p> <p>In the following example we copy sources from a folder to the build folder (we assume these sources are generated with ai):</p> <pre><code>tasks.register&lt;Copy&gt;(\"generateMlCode\") {\n    from(rootProject.layout.projectDirectory.dir(\"mlCodeGenTemplate\"))\n    into(layout.buildDirectory.dir(\"generated/sources/mlCode\"))\n}\n\nsourceSets {\n    main {\n        java {\n            srcDir(tasks.named(\"generateMlCode\"))\n            // Note: DO NOT do the following\n            srcDir(layout.buildDirectory.dir(\"generated/sources/mlCode\"))\n        }\n    }\n}\n</code></pre>"},{"location":"gradle/webinars/official/jvm-builds/#running-expensive-tests","title":"Running Expensive Tests","text":"<p>Unit tests must execute fast, becuase developers run them frequently after small changes to verify the tests. Now if running these tests takes alot of time, developers might not run them as often. (Slow tests are database tests or tests with network requests, etc)</p> <p></p> <p>By defining a separate sourceSet for expensive tests allows us to run fast tests separatelt from them and run expensive tests when needed.</p> <p></p> <p>Junit Tags</p> <p>If junit is the test framework, we can use test tags to run parts of tests not all of them. but not all test framework provide this feature.</p> <p>Using separate sourceSet has another benefit: Expensive tests require different dependencies which we can only add to their sourceSet alone and fast tests do not have those dependencies</p> <p>Android Framework tests</p> <p>In android for tests related to android framework which needs an android emulator to execute, they have defined a separate sourceSets called androidTest.</p>"},{"location":"gradle/webinars/official/jvm-builds/#soucesets-more-than-just-sources","title":"SouceSets: More than Just Sources","text":"<p>Beside Source Locations, there are more information within a sourceSet:</p> <ul> <li>Dependencies</li> <li>Classpath for compilation and runtime</li> <li>Input classes: Where are our sources?</li> <li>Impl configuration: What configuration to use to add a dependency to it.</li> <li>Output classes: Where are java class bytecodes</li> </ul> <p>Using the following code, you can findout about these informations:</p> <pre><code>import java.nio.file.Paths\n\ntasks.register(\"sourceSetsInfo\") {\n    doLast {\n        fun isInGradleDirectory(file: File): Boolean {\n            var parent: File? = file.parentFile\n            while (parent != null) {\n                if(parent.name == \".gradle\") {\n                    return true\n                }\n                parent = parent.parentFile\n            }\n\n            return false\n        }\n\n        val projectPath = layout.projectDirectory.asFile.toPath()\n        val gradleHomePath = gradle.gradleUserHomeDir.toPath()\n        val cachePath = Paths.get(gradleHomePath.toString(), \"caches/modules-2/files-2.1/\")\n\n        sourceSets.forEach { sourceSet -&gt;\n            println()\n            println(\"[${sourceSet.name}]\")\n\n            println(\"\\tsrcDirs:\")\n            sourceSet.allSource.srcDirs.forEach { dir -&gt;\n                println(\"\\t\\t${projectPath.relativize(dir.toPath())}\")\n            }\n\n            println(\"\\tsrcDirs:\")\n            sourceSet.output.classesDirs.files.forEach { file -&gt;\n                println(\"\\t\\t${projectPath.relativize(file.toPath())}\")\n            }\n\n            println(\"\\timpl dependency configuration:\")\n            println(\"\\t\\t${sourceSet.implementationConfigurationName}\")\n\n            println(\"\\tCompile Task:\")\n            println(\"\\t\\t${sourceSet.compileJavaTaskName}\")\n\n            println(\"\\tCompile Classpath:\")\n            sourceSet.compileClasspath.files.forEach { file -&gt;\n                if(isInGradleDirectory(file)) {\n                    println(\"\\t\\t${cachePath.relativize(file.toPath())}\")\n                } else {\n                    println(\"\\t\\t${projectPath.relativize(file.toPath())}\")\n\n                }\n            }\n\n            println(\"\\tRuntime Classpath:\")\n            sourceSet.runtimeClasspath.files.forEach { file -&gt;\n                if(isInGradleDirectory(file)) {\n                    println(\"\\t\\t${cachePath.relativize(file.toPath())}\")\n                } else {\n                    println(\"\\t\\t${projectPath.relativize(file.toPath())}\")\n\n                }\n            }\n\n        }\n    }\n}\n</code></pre> <p>Note: Android SourceSets have slightly different API</p>"},{"location":"gradle/webinars/official/jvm-builds/#define-additional-sourcesets","title":"Define Additional SourceSets","text":"<p>We define addional sourceSets to manage code that is logically independent (e.g test types). - Since test frameworks may have different dependencies and classpaths, we define addtional sourceSets for them to executes different test types separately.</p> <p>Creating a sourceSet is easy as follows:</p> <pre><code>sourceSets.create(\"srcSetName\")\n</code></pre> <p>And after this, if we run <code>sourceSetsInfo</code> tasks, then we will see this sourceSet in the list as well, and we can use it's sepecific dependency configuration to add a dependency to it.</p> <p>Now for example let's consider a extra sourceSet which has a main method, let's define a task similir to <code>run</code> to run this sourceSet:</p> ./src/extra/Extra.java<pre><code>import org.joda.time.LocalTime;\npublic class Extra {\n    public static void main(String[] args) {\n        System.out.println(\"Running Extra: \" + LocalTime.now().toString());\n    }\n}\n</code></pre> build.gradle.kts<pre><code>val extraSrcSet = sourceSets.create(\"extra\")\ndependencies {\n    \"extraImplementation\"(\"joda-time:joda-time:2.11.1\")  //(1)!\n}\ntasks.register&lt;JavaExec&gt;(\"runExtra\") { //(2)!\n    classpath = extraSrcSet.output + extraSrcSet.runtimeClasspath //(3)!\n    mainClass.set(\"Extra\")\n}\n</code></pre> <ol> <li>extraImplementation is the output of <code>extraSrcSet.implementationConfigurationName</code></li> <li>JavaExec is a predefined task type which requires classpath and mainclass to be set. For more task types check here.</li> <li>For classpath two values are concatenated: <ul> <li>sourceSet output so we have access to .class files inside extra package (as well as declare an inferred dependency on Compile task of this sourceSet, so before running this task, extra files are compiled first)</li> <li>runtimeClasspath because we need the declared dependencies to run the jar file. </li> </ul> </li> </ol>"}]}